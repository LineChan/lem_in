<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>lem-in: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">lem-in
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">README </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>School Project : Algorithm (2)</p>
<h1>Lem_in</h1>
<ul>
<li><a href="#subject">Subject</a></li>
<li><a href="#method">Method</a></li>
<li><a href="#help">Help</a></li>
</ul>
<h1>Subject :pushpin:</h1>
<p>Lem_in is a path finding game. The goal is to find the quickest way to get all ants from an anthill from the entrance to the exit. At the <b>beginning of the game</b>, all the ants are in the room ##start. At <b>each turn</b>, an ant can only move once through a tube. Be careful, the receiving room must be empy because it can only contain one ant at a time (except for the ##end room). The game is done when all the ants are at the exit.</p>
<p>Here is an example of an input : </p><div class="fragment"><div class="line">7                    <span class="comment">/* Number of ants */</span></div><div class="line"><span class="preprocessor">##start              </span><span class="comment">/* Rooms&#39; List : room_name x_position y_position */</span><span class="preprocessor"></span></div><div class="line">r_start 00 00</div><div class="line">r_1 10 60</div><div class="line">r_2 40 30</div><div class="line">r_3 40 00</div><div class="line">r_4 45 70</div><div class="line">r_5 70 20</div><div class="line">r_6 30 60</div><div class="line"><span class="preprocessor">##end</span></div><div class="line">r_end 70 70</div><div class="line">r_start-r_1          <span class="comment">/* Tubes&#39; List : room_name1-room_name2 */</span></div><div class="line">r_start-r_2</div><div class="line">r_start-r_3</div><div class="line">r_1-r_6</div><div class="line">r_4-r_6</div><div class="line">r_3-r_5</div><div class="line">r_4-r_end</div><div class="line">r_2-r_end</div><div class="line">r_5-r_end</div></div><!-- fragment --><p>The output of the program is displayed like this :</p><ul>
<li>Number of ants</li>
<li>Room List</li>
<li>Tube List</li>
<li>L1-x L2-y L3-z ... 1,2,3 represents the ants' numbers and x,y,z the rooms' names</li>
</ul>
<div class="fragment"><div class="line">L1-r_2 L2-r_3 L3-r_1                         <span class="comment">/* each line represents a move */</span></div><div class="line">L1-r_end L4-r_2 L2-r_5 L5-r_3 L3-r_6</div><div class="line">L4-r_end L6-r_2 L2-r_end L5-r_5 L3-r_4</div><div class="line">L6-r_end L7-r_2 L5-r_end L3-r_end</div><div class="line">L7-r_end</div></div><!-- fragment --><p><b>Allowed function</b> : write, read, malloc, free, exit, strerror, perror</p>
<h3>Libraries :books:</h3>
<ul>
<li><b>libft</b> : personnal library with functions from libc.h (printf from stdio.h for instance)</li>
<li><b>liblst</b> : personnal library with a set of tools to manipulate Linux-like linked lists</li>
<li><b>pygame</b> : for bonuses only</li>
</ul>
<h1>Method</h1>
<h2>Parsing</h2>
<p>For the parsing I made a <b>grammatical analysis</b> of the input format and build my function according to it. Note : Any unknown command is ignored (lines starting with ##) and any non compliant or empty lines will automatically stop the parsing. The programm process only the already acquired data.</p>
<div class="fragment"><div class="line">&lt;start&gt;         : &lt;ant&gt; &lt;new_line&gt; &lt;room_list&gt; &lt;new_line&gt; &lt;tube_list&gt;</div><div class="line"></div><div class="line">&lt;ant&gt;           : &lt;number&gt;</div><div class="line"></div><div class="line">&lt;number&gt;        : &lt;digit&gt; [&lt;number&gt;]</div><div class="line"></div><div class="line">&lt;digit&gt;         : [0-9]</div><div class="line"></div><div class="line">&lt;room_list&gt;     : &lt;room_id&gt; &lt;new_line&gt; [&lt;room_list&gt;]</div><div class="line">                | <span class="charliteral">&#39;#&#39;</span> &lt;command&gt; &lt;new_line&gt; [&lt;room_list&gt;]</div><div class="line">                | <span class="charliteral">&#39;#&#39;</span> &lt;word&gt; &lt;new_line&gt; [&lt;room_list&gt;]</div><div class="line"></div><div class="line">&lt;room_id&gt;       : &lt;room_name&gt; <span class="charliteral">&#39; &#39;</span> &lt;number&gt; <span class="charliteral">&#39; &#39;</span> &lt;number&gt;</div><div class="line"></div><div class="line">&lt;command&gt;       : <span class="charliteral">&#39;#&#39;</span> &lt;command_start&gt;</div><div class="line">                | <span class="charliteral">&#39;#&#39;</span> &lt;command_end&gt;</div><div class="line">                | <span class="charliteral">&#39;#&#39;</span> &lt;word&gt;</div><div class="line"></div><div class="line">&lt;command_start&gt; : <span class="stringliteral">&quot;start&quot;</span> &lt;new_line&gt; &lt;room_id&gt;</div><div class="line"></div><div class="line">&lt;command_end&gt;   : <span class="stringliteral">&quot;end&quot;</span> &lt;new_line&gt; &lt;room_id&gt;</div><div class="line"></div><div class="line">&lt;tube_list&gt;     : &lt;tube_id&gt; [&lt;tube_list&gt;]</div><div class="line">                | <span class="charliteral">&#39;#&#39;</span> &lt;word&gt; [&lt;tube_list&gt;]</div><div class="line"></div><div class="line">&lt;room_name&gt;     : &lt;first_letter&gt; [&lt;word&gt;]</div><div class="line"></div><div class="line">&lt;word&gt;          : &lt;letter&gt; [&lt;word&gt;]</div><div class="line"></div><div class="line">&lt;first_letter&gt;  : [A-Z] - L</div><div class="line">                | [a-z]</div><div class="line">                | &lt;number&gt;</div><div class="line"></div><div class="line">&lt;letter&gt;        : &lt;first_letter&gt;</div><div class="line">                | [<span class="charliteral">&#39;L&#39;</span>,<span class="charliteral">&#39; &#39;</span>,<span class="charliteral">&#39;#&#39;</span>, <span class="charliteral">&#39;-&#39;</span>, <span class="charliteral">&#39;.&#39;</span>]</div><div class="line"></div><div class="line">&lt;tube_id&gt;       : &lt;room_name&gt; <span class="charliteral">&#39;-&#39;</span> &lt;room_name&gt; &lt;new_line&gt;</div><div class="line"></div><div class="line">&lt;new_line&gt;      : <span class="charliteral">&#39;\n&#39;</span></div></div><!-- fragment --><p>NB : you can visualize the parsing process with the <b>&ndash;parsing</b> option</p>
<h2>Path finding algorithm</h2>
<p>The anthill with its rooms and tubes can be analyzed as a graph that is:</p><ul>
<li><b>unweighted</b> : all the edges have the same weight (it costs one turn each time an ant moves)</li>
<li><b>undirected</b> : there is no directed edges (an ant go through a tube in both directions)</li>
<li><b>cyclic</b> : there are circles in the graph (possibility to go twice in the same room withe same ant)</li>
</ul>
<p>To find solutions I decided to implement an <b>Iterative Deepening Depth-First Search</b> (IDDFS). I chose that algorithm because it combines Breadth-First Search's (<a href="http://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/">BSF</a>) fast search (for vertices closer to root) and Depth-Dirst Search's (<a href="http://www.geeksforgeeks.org/depth-first-traversal-for-a-graph/">DSF</a>) space-efficiency. Also, the IDDSF guarentees that each path found is <b>the shortest one</b> available.</p>
<p>The IDDSF calls DFS for different depths starting from an initial value. In every call, DFS is restricted from going beyond given depth. Because it is a DSF executed in a BFS fashion, the algorithm is easy to adapt to find <b>multiples shortest paths</b> by giving different initial values.</p>
<div class="image">
<img src="/img/readme_img.png" alt="graph"/>
</div>
<p>Top level nodes are visited <b>multiples times</b>. The last (or max depth) level is visited once, second last level is visited twice, and so on. It may seem expensive, but it turns out to be not so costly, since in a tree most of the nodes are in the bottom level. So it does not matter much if the upper levels are visited multiple times.</p>
<p>Because the IDDFS works only on <b>acyclic</b> graphs, I used an <a href="https://en.wikipedia.org/wiki/Adjacency_matrix">adjacency matrix</a> I adapted so a vertex can't be visited multiple times (see :arrow_down: DLS). The matrix can take 3 values :</p><ul>
<li>1 : if the pairs of vertices are adjacent (there is a tube between two rooms)</li>
<li>0 : if not</li>
<li>-1 : if the vertex has already been visited</li>
</ul>
<h3>IDDFS</h3>
<p>In our case, the <b>maximum depth</b> is the number of rooms (ROOM_NB). Indeed, if there is a solution, the longest path possible goes through all rooms once. Before starting the IDDFS, the <b>maximal number of shortest paths</b> (SP_NB) is also defined. We simply look the number of rooms linked to the ##start and ##end rooms and take the lower one.</p>
<p>Example : the ##start rooms has 2 tubes and the ##end room has 3 tubes&ndash;&gt; SP_NB = 2 . In the best case, both paths are shortest paths from ##start to <b>2 out of 3 adjacent rooms</b> of ##end.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span>              <a class="code" href="lem__in_8h.html#afe569fc468752b5c5e8538c576233c14">ft_iddfs</a>(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span>          limit;</div><div class="line"></div><div class="line">    limit = 0;</div><div class="line"></div><div class="line">    <span class="comment">/* Loop until all the shortest path aren&#39;t found */</span></div><div class="line">    <span class="keywordflow">while</span> (<a class="code" href="lem__in_8h.html#a52db328fbeffcc95caa8f7650bb98afd">SP_NB</a> &gt; 0)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Repeadted Depth-Limit Search until the maximum depth */</span></div><div class="line">        <span class="keywordflow">while</span> (limit &lt; <a class="code" href="lem__in_8h.html#a5adb0e39ac47d6ad5b8253f9fb1528ab">ROOM_NB</a>)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">if</span> (<a class="code" href="ft__iddfs_8c.html#a8405adeaef2c837ae895df84edfc32f0">ft_dls</a>(<a class="code" href="lem__in_8h.html#ad3612a6933e5438fe679a6a8131a3a79">START_REF</a>, limit))</div><div class="line">                break ;</div><div class="line">            ++limit;</div><div class="line">        }</div><div class="line">        --<a class="code" href="lem__in_8h.html#a52db328fbeffcc95caa8f7650bb98afd">SP_NB</a>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (ft_lst_is_head(&amp;<a class="code" href="lem__in_8h.html#a5b49a1ba9b3d55222c1ea3e7a0662003">SHORTEST_PATH</a>))</div><div class="line">        <span class="keywordflow">return</span> (0);</div><div class="line">    <span class="keywordflow">return</span> (1);</div><div class="line">}</div></div><!-- fragment --><h3>DLS</h3>
<p>Depth-Limit Search is a recursive function that starts from a given source and stops when the ##end room is found or the depth limit is reached (no solution).</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span>       <a class="code" href="ft__iddfs_8c.html#a8405adeaef2c837ae895df84edfc32f0">ft_dls</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> src_ref, <span class="keyword">const</span> <span class="keywordtype">int</span> limit)</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span>          i;</div><div class="line"></div><div class="line">    <span class="comment">/* Result found */</span></div><div class="line">    <span class="keywordflow">if</span> (src_ref == <a class="code" href="lem__in_8h.html#ab5c07adf32d9bf6d7e2f61ba5339a131">END_REF</a>)</div><div class="line">        <span class="keywordflow">return</span> (1);</div><div class="line"></div><div class="line">    <span class="comment">/* Limit depth reached*/</span></div><div class="line">    <span class="keywordflow">if</span> (limit &lt;= 0)</div><div class="line">    {</div><div class="line">        <a class="code" href="lem__in_8h.html#a6f1b2b16bbb8e315a2c20f723a4ac649">ft_reset_matrix</a>();</div><div class="line">        <span class="keywordflow">return</span> (0);</div><div class="line">    }</div><div class="line">    i = 0;</div><div class="line"></div><div class="line">    <span class="comment">/* Set the node as visited */</span></div><div class="line">    <span class="keywordflow">while</span> (i &lt; <a class="code" href="lem__in_8h.html#a5adb0e39ac47d6ad5b8253f9fb1528ab">ROOM_NB</a>)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (!(<a class="code" href="lem__in_8h.html#af1d98fb728b5c7300f80dd782702d1dd">MATRIX</a>[i][src_ref] ^ 1))</div><div class="line">            <a class="code" href="lem__in_8h.html#af1d98fb728b5c7300f80dd782702d1dd">MATRIX</a>[i][src_ref] = -1;</div><div class="line">        ++i;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Start DLS from adjacent nodes */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="ft__iddfs_8c.html#af0068e42aa4977deea1889f1e156a3d2">ft_explore_adjacent</a>(src_ref, limit))</div><div class="line">        <span class="keywordflow">return</span> (1);</div><div class="line">    <span class="keywordflow">return</span>  (0);</div><div class="line">}</div></div><!-- fragment --><h3>Exploring adjacent nodes</h3>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span>         <a class="code" href="ft__iddfs_8c.html#af0068e42aa4977deea1889f1e156a3d2">ft_explore_adjacent</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> ref, <span class="keyword">const</span> <span class="keywordtype">int</span> limit)</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span>            i;</div><div class="line">    <span class="keywordtype">int</span>            j;</div><div class="line"></div><div class="line">    i = 0;</div><div class="line">    <span class="keywordflow">while</span> (i &lt; <a class="code" href="lem__in_8h.html#a5adb0e39ac47d6ad5b8253f9fb1528ab">ROOM_NB</a>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* If it is an adjancent and on the shortest path */</span></div><div class="line">        <span class="keywordflow">if</span> ((<a class="code" href="lem__in_8h.html#af1d98fb728b5c7300f80dd782702d1dd">MATRIX</a>[ref][i] == 1) &amp;&amp; (<a class="code" href="ft__iddfs_8c.html#a8405adeaef2c837ae895df84edfc32f0">ft_dls</a>(i, limit - 1)))</div><div class="line">        {</div><div class="line">            <span class="keywordflow">if</span> (i != <a class="code" href="lem__in_8h.html#ab5c07adf32d9bf6d7e2f61ba5339a131">END_REF</a>)</div><div class="line">            {</div><div class="line">                <span class="comment">/* If it isn&#39;t the ##end room, move the room from the anthill</span></div><div class="line"><span class="comment">                to the shortest path list */</span></div><div class="line">                ft_lst_moveto_next(<a class="code" href="lem__in_8h.html#a29508c2082c43ec9e8b1f7cb4f45eb17">ft_find_room_with_ref</a>(&amp;<a class="code" href="lem__in_8h.html#a46b8401cf2a791830e62d5c1e33c588b">ANTHILL</a>, i), &amp;<a class="code" href="lem__in_8h.html#a104d77926a788edb0e8f20c414bfc706">PATH</a>(<a class="code" href="lem__in_8h.html#a5b49a1ba9b3d55222c1ea3e7a0662003">SHORTEST_PATH</a>.prev));</div><div class="line">                j = 0;</div><div class="line">                <span class="comment">/* Removing the room from matrix by setting the value to 0 */</span></div><div class="line">                <span class="keywordflow">while</span> (j &lt; <a class="code" href="lem__in_8h.html#a5adb0e39ac47d6ad5b8253f9fb1528ab">ROOM_NB</a>)</div><div class="line">                    <a class="code" href="lem__in_8h.html#a8a7afa03fea12ca81f1bf9cfec41c3a8">ft_set_matrix</a>(i, j++, 0);</div><div class="line">            }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">            {</div><div class="line">                <span class="comment">/* Create a shortest path list and copy the ##end room at the end of it */</span></div><div class="line">                <span class="comment">/* NB : Because the IDDFS always finds the shortest path,</span></div><div class="line"><span class="comment">                solutions are sorted from the shortest to the longest) */</span></div><div class="line">                <a class="code" href="lem__in_8h.html#a8db7fffa0bea82950917eb04425448bb">ft_add_shortest_path</a>();</div><div class="line">                <a class="code" href="lem__in_8h.html#a3b976ac1802a5c5cfedda234549d1e20">ft_copy_end_room_to_path</a>();</div><div class="line">            }</div><div class="line">            ++<a class="code" href="lem__in_8h.html#a5b82d9e3ecf74ade26fdef1e086be2ea">PATH_LEN</a>(<a class="code" href="lem__in_8h.html#a5b49a1ba9b3d55222c1ea3e7a0662003">SHORTEST_PATH</a>.prev);</div><div class="line">            <span class="keywordflow">return</span> (1);</div><div class="line">        }</div><div class="line">        ++i;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> (0);</div><div class="line">}</div></div><!-- fragment --><h2>Computing moves</h2>
<p>Now that we have SP_NB shortest path, ants need to be sent on these paths. To minimize the number of moves, paths are taken according to these rules :</p><ul>
<li><b>1st shortest path</b> (best solution) : an ant is sent at each turn</li>
<li><b>Other paths</b> : an ant is sent if only it is less cost-effective to take the current path than the shortest one.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="lem__in_8h.html#a5b82d9e3ecf74ade26fdef1e086be2ea">PATH_LEN</a>(current_path) &lt;= ((<a class="code" href="lem__in_8h.html#ad36c0067ae971285080672f71df4668d">ANT_NB</a> - current_ant) * <a class="code" href="lem__in_8h.html#a5b82d9e3ecf74ade26fdef1e086be2ea">PATH_LEN</a>(BEST_SHORTEST_PATH)))</div><div class="line">    ft_sent_ant(&amp;<a class="code" href="lem__in_8h.html#a104d77926a788edb0e8f20c414bfc706">PATH</a>(current_path), &amp;current_ant);</div></div><!-- fragment --><h1>Bonuses</h1>
<ul>
<li>[ ] Call and caller graphs of the project</li>
<li>[x] Parsing details</li>
<li>[x] Chose of the number of shortest paths that can be found</li>
<li>[x] Interactive anthill visualization</li>
</ul>
<h1>Sources :bookmark_tabs:</h1>
<ul>
<li>MIT Open Course Ware :<ul>
<li><a href="https://www.youtube.com/watch?v=s-CYnVz-uh4&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=13"><em>Breadth-First Search</em></a></li>
<li><a href="https://www.youtube.com/watch?v=AfSk24UTFS8&amp;index=14&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb"><em>Depth-First Search, topological sort</em></a></li>
<li><a href="https://www.youtube.com/watch?v=Aa2sqUhIn-E&amp;index=15&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb"><em>Single source shortest path</em></a></li>
<li><a href="https://www.youtube.com/watch?v=2E7MmKv0Y24&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=16"><em>Djisktra</em></a></li>
</ul>
</li>
<li>University of British Colombia pdf :<ul>
<li><a href="http://www.cs.ubc.ca/~mack/CS322/lectures/2-Search6.pdf"><em>Iterative deepening and IDA</em> *</a></li>
</ul>
</li>
<li>Geek for geeks website :<ul>
<li><a href="http://www.geeksforgeeks.org/iterative-deepening-searchids-iterative-deepening-depth-first-searchiddfs/"><em>Iterative Deepening Search</em></a></li>
</ul>
</li>
<li>Others :<ul>
<li><a href="https://qiao.github.io/PathFinding.js/visual/"><em>Path finding algorithm visualisation</em></a></li>
<li><a href="http://www.linux-france.org/article/devl/lexyacc/minimanlexyacc.html#toc2"><em>Lex and Yacc</em></a></li>
</ul>
</li>
</ul>
<h1>Help :heavy_exclamation_mark:</h1>
<p><b>Importing libraries in submodules</b> [work in progress] &gt; ./lem-in [&ndash;parsing] [&ndash;shortest_path=nb] &lt; ant_farm_map.txt</p>
<p><b>parsing</b> : shows the grammatical analysis of the parsing</p>
<p><b>shortest_path nb</b> : by default the program finds all possible shortest path. The proccess can be a bit slow for a hight number of rooms and tubes so it is possible to restrain the solutions with this option</p>
<pre class="fragment">&gt; python3 main.c ant_farm_map.txt
</pre><p><b>visualisation</b> : (work in progress) </p><div class="image">
<img src="/img/readme_visual.png" alt="visual"/>
</div>
<h1>Result</h1>
<p>Peer evaluation not done yet. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
